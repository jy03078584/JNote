#JVM
>摘要笔记：《深入理解Java虚拟机2》

[TOC]

##JVM类加载机制
###jvm类加载生命周期
【加载】——【验证】——【准备】——【解析】——【初始化】——【使用】——【卸载】

##[加载]
* 通过类的全限定类名获取二进制字节流
* 将字节流代表的静态存储结构转化为方法区的运行时数据结构
* 在内存中生成java.lang.Class对象,作为方法区这个累的访问入口

**对于数组对象，数组对象本身不依靠类加载器加载，但数组的元素对象则需要类加载器加载**

##[验证]
>验证阶段能确保Class文件中的字节流符合JVM规范

* 文件格式验证:
验证字节流是否符合Class文件格式的规范(是否以魔数开头、主次版本号是否在JVM处理范围类...)
* 元数据验证:
验证是否符合Java语言规范(是否有父类、子类是否继承了final修饰物、是否实现了接口的所有方法...)
* 字节码验证:
验证字节码定义的程序合法、符合逻辑(跳转指令不会跳转到方法体外、存取类型是否一致...)
* 符号引用验证

**验证阶段不是必须的,对于已经使用多次能确保安全准确的代码可以考虑使用 -Xverify:none关闭验证**


##[准备]
- 准备阶段为static变量(*实例变量实例化时在堆分配*)分配内存并设置初始值

```java
//准备阶段 value被分配内存 并初始化为0 到【初始化】阶段才会赋值为123
public static int value = 123;

//对于被final修饰的变量 才会在【准备】阶段被赋值为123
public final static int value = 123;
```

##[解析]
- 类和接口解析
- 字段解析
- 类方法(static)解析
- 接口方法解析


##[初始化]
【初始化】阶段是加载的最后阶段，是执行<client>()方法的过程,该过程中<client>()会收集类变量(static)和static代码块中语句对类变量进行赋值。

+ static块中语句能对变量的赋值没有顺序要求，**但只不能访问定义在static语句块后的变量**
```java
 static{
	i = 0;//static中能对定义在static块后的变量赋值
	System.out.println(i);//报错：static不能访问定义在static块后的变量
}
public static int i = 10;
```


<hr>

###类被加载的时机

**JVM规定有且只有以下5种情况，类才会被加载**

* 使用new实例化对象、读取/设置static字段(除开final static)、调用staitc方法
* 使用java.lang.reflect对类进行反射操作时
* 初始化一个类时,若父类未初始化会先初始化父类
* 被指定为主类的类会被优先初始化(void main)
* 使用JDK1.7的java.lang.invoke.MethodHandler

**以下情况不会初始化**

* 子类调用父类的static字段只会初始化父类，并不会初始化子类:即只有直接定义static字段的类才会被初始化
* MyClass[] mc = new MyClass[10]。new 数组的方式也不会初始化类，JVM会自动生成一个额外的类
* 在B类调用A类的final static字段，JVM会在编译阶段做优化，将A中的final static字段转存到B类中，则在调用时并不会初始化A类

**类在初始化时要求父类全部初始化，接口则要求真正使用到父类接口时才会初始化**
